# 03 - 基础指令集

> 为什么寄存器都是**5位**？
>
> 因为riscv有32个寄存器，所以 `2^5` 正好可以表示全部的寄存器。

```mermaid
---
title: RISC-V
config:
    block:
        padding : 10
        font_size : 20
---
block-beta

columns 35
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 type["tp"]:3

block:g_1_1:7
    l_1_1("funct7")
end
block:g_1_2:5
    l_1_2("rs2")
end
block:g_1_3:5
    l_1_3("rs1")
end
block:g_1_4:3
    l_1_4("funct3")
end
block:g_1_5:5
    l_1_5("rd")
end
block:g_1_6:7
    l_1_6("opcode")
end
block:g_1_7:3
    l_1_7("R-type")
end

block:g_2_1:12
    l_2_1("[11:0]")
end
block:g_2_2:5
    l_2_2("rs1")
end
block:g_2_3:3
    l_2_3("funct3")
end
block:g_2_4:5
    l_2_4("rd")
end
block:g_2_5:7
    l_2_5("opcode")
end
block:g_2_7:3
    l_2_7("I-type")
end

block:g_3_1:7
    l_3_1("[11:5]")
end
block:g_3_2:5
    l_3_2("rs2")
end
block:g_3_3:5
    l_3_3("rs1")
end
block:g_3_4:3
    l_3_4("funct3")
end
block:g_3_5:5
    l_3_5("[4:0]")
end
block:g_3_6:7
    l_3_6("opcode")
end
block:g_3_7:3
    l_3_7("S-type")
end

block:g_4_1:1
    l_4_1("12")
end
block:g_4_9:6
    l_4_9("[10:5]")
end
block:g_4_2:5
    l_4_2("rs2")
end
block:g_4_3:5
    l_4_3("rs1")
end
block:g_4_4:3
    l_4_4("funct3")
end
block:g_4_5:4
    l_4_5("[4:1]")
end
block:g_4_8:1
    l_4_8("11")
end
block:g_4_6:7
    l_4_6("opcode")
end
block:g_4_7:3
    l_4_7("B-type")
end

block:g_5_1:20
    l_5_1("[31:12]")
end
block:g_5_2:5
    l_5_2("rd")
end
block:g_5_3:7
    l_5_3("opcode")
end
block:g_5_4:3
    l_5_4("U-type")
end

block:g_6_1:1
    l_6_1("20")
end
block:g_6_5:10
    l_6_5("[10:1]")
end
block:g_6_6:1
    l_6_6("11")
end
block:g_6_7:8
    l_6_7("[19:12]")
end
block:g_6_2:5
    l_6_2("rd")
end
block:g_6_3:7
    l_6_3("opcode")
end
block:g_6_4:3
    l_6_4("U-type")
end

classDef pink 1,fill:#FFCCCC,stroke:#333, color: #fff, font-weight:bold;
classDef pale_pink fill:#E1BEE7,color:#000000;
classDef green fill: #696,color: #fff,font-weight: bold;
classDef purple fill:#969,stroke:#333, font-weight: bold;
classDef error fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5
classDef coral fill:#f9f,stroke:#333,stroke-width:4px;
classDef animate stroke-dasharray: 9,5,stroke-dashoffset: 900,animation: dash 25s linear infinite;
classDef yellow fill:#FFF9C4,color:#000000;

class l_1_7 green
class l_2_7 green
class l_3_7 green
class l_4_7 green
class l_5_4 green
class l_6_4 green

class l_1_6 error
class l_2_5 error
class l_3_6 error
class l_4_6 error
class l_5_3 error
class l_6_3 error

class l_2_1 yellow
class l_3_1 yellow
class l_3_1 yellow
class l_4_1 yellow
class l_3_5 yellow
class l_4_5 yellow
class l_5_1 yellow
class l_6_1 yellow
class l_4_9 yellow
class l_4_8 yellow
class l_6_5 yellow
class l_6_6 yellow
class l_6_7 yellow

class l_1_1 animate
class l_1_4 animate
class l_2_3 animate
class l_3_4 animate
class l_4_4 animate

class l_1_2 pink
class l_1_3 pink
class l_1_5 pink
class l_2_2 pink
class l_2_4 pink
class l_3_2 pink
class l_3_3 pink
class l_4_2 pink
class l_4_3 pink
class l_5_2 pink
class l_6_2 pink


class 31 green
class 30 green
class 29 green
class 28 green
class 27 green
class 26 green
class 25 green
class 24 green
class 23 green
class 22 green
class 21 green
class 20 green
class 19 green
class 18 green
class 17 green
class 16 green
class 15 green
class 14 green
class 13 green
class 12 green
class 11 green
class 10 green
class 9 green
class 8 green
class 7 green
class 6 green
class 5 green
class 4 green
class 3 green
class 2 green
class 1 green
class 0 green
class type green

```

- opcode（操作码）字段：位于指令编码Bit[6:0]，用于指令的分类
- funct3和funct7（功能码）字段：常常与opcode字段结合在一起使用，用来定义指令的操作功能
- `rd`, `rs` 分别表示目标寄存器和源寄存器
- imm 表示立即数

## 3.3 加载与存储指令集

### 加载指令

```assembly
l{d|w|h|b}{u} rd, offset(rs1)
```

| 加载指令           | 位宽 | 描述                                                         |
| ------------------ | ---- | ------------------------------------------------------------ |
| ld rd, offset(rs1) | 8    | 以rs1中的地址作为基址，在偏移offset处加载`1`字节，经过符号扩展后写入rd |
| lh rd, offset(rs1) | 16   | 以rs1中的地址作为基址，在偏移offset处加载`2`字节，经过符号扩展后写入rd |
| lui rd, imm        | 64   | 将立即数imm左移12位，然后进行符号扩展，最后把结果写入rd      |

#### 例3-2

- `符号扩展`是计算机系统把小字节数据转换成大字节数据的规则之一，它将符号位扩展至所需要的位数：**符号扩展中，填充的是原数据的符号位（最高位）**
- `零扩展`按照无符号数处理，因此高字节部分填充为0

```assembly
li t0, 0x8000000				; 伪指令，把立即数加载到t0

lb t1, (t0)							; 以t0寄存器的值为基地址的内存中加载1字节的数据到t1寄存器，并对这1字节的数据进行符号扩展
lb t1, 4(t0)						; 以t0的值为基址的内存在偏移4字节后加载一字节到t1，并对这1字节进行符号扩展
lbu t1, 4(t0)						; 以t0的值为基址的内存在偏移4字节后加载一字节到t1，并对这1字节进行零扩展

lb t1, -4(t0)
ld t1, (t0)
ld t1, 16(t0)
```

#### 例3-3

`lui` 的全称是 `Load Upper Immediate`，作用是加载立即数到目标寄存器的高20位。

```assembly
lui t0, 0x80200
lui t1, 0x40200
```

#### 例-34

在这个例子中，偏移量超过了 `byte` 的取值范围，编译器会报错。

```assembly
lb a1, 2048(a0)
lb a1, -2049(a0)
```

### 存储指令

```assembly
s{d|w|h|b}{u} rs2, offset(rs1)
```

| 加载指令            | 位宽 | 描述                                                |
| ------------------- | ---- | --------------------------------------------------- |
| sb rs2, offset(rs1) | 8    | 把rs2的低8位写入到以rs1为基址的地址偏移offset的位置 |

## 3.4 PC相对寻址

程序计数器(Program Counter, PC)用来指示下一条指令的地址。为了保证CPU正确地执行程序的指令代码，CPU必须知道下一条指令的地址，这就是程序计数器的作用，程序计数器通常是一个寄存器。

### AUIPC

`auipc` 将 `imm` 左移 `12` 位并扩展，**再加上当前PC**后存到寄存器rd：

- 它是有符号的，用于相对偏移
- 左移后的立即数表示的是地址的高20位，所以他的寻址范围基于当前PC的偏移量`±2GB`
- 由于新的立即数低12位是0，所以只能寻址到与4KB对齐的地址，如果需要更细的寻址，需要其他指令的配合（类似于 `ADDI`）

```assembly
# Add Upper Immediate Prgoram Counter
auipc rd, imm
```

### LUI

`lui` 将立即数左移12位，得到一个新的32立即数，再带符号扩展到64位，将其存储到rd寄存器中

```assembly
lui a6, 0x2
```

#### 3-5

```assembly
# PC = 0x8020 0000

auipc a5, 0x2 		# a5 = 0x8020 2000
lui   a6, 0x2 		# a6 = 0x0000 2000
```

### ADDI

![3-8](pic/3-8.png)

`ADDI` 指令可以在 `[−2048, 2047]` 范围内寻址，即被访问地址的低12位。

```c
// 存在一个地址，这个地址是基于原始pc经过auipc和addi两条指令操作后得到的地址
// 假设地址是ptr，pc是原始地址，offset是地址与当前PC值的偏移量
// hi20 和 lo12 的公式

// offset[11] 是为了抵消12位有符号数的影响：
// 在我们的实际寻址过程中，auipc 操作的立即数 imm 实际是表示的 imm << 12 这个值
// 假设auipc的结果是x，addi的操作数是 addi_imm
// 在我们的实际寻址过程中，可能有两种不同的寻址方式
// addi_imm 为正数，由 x 向右偏移得到offset
// addi_imm 为负数，由 x 向左偏移得到offset
// 也就是，当 addi_imm 为负数的时候，auipc 操作的立即数需要额外的跳转4KB
hi20 = (offset >> 12) + offset[11];
lo12 = offset & 0xfff
```

使用AUIPC和ADDI指令对地址B进行寻址。

```assembly
auipc		a0, hi20
addi		a1, a0, lo12
```

![3-9](pic/3-9.png)

在上面这个图中，`offset` 是我们相对于PC的偏移量。地址B为0x8020 1800，地址B正好在4 KB的正中间，地址B与地址A的偏移量为2048字节，与地址C的偏移量为−2048字节

此时，我们的实际 `offset` 可能有两种计算方式：

- `A` + `lo12`
- `C` - `lo12`

但是由于 `A` + `lo12` 计算的话，**lo12 == 2048** 超过了 lo12 的取值范围。

### 与PC相关的加载和存储伪指令

> 计算上述hi20和lo12的过程通常由链接器在重定位时完成：
>
> - PIC表示生成与位置无关的代码(Position Independent Code)
> - GOT表示全局偏移量表(Global Offset Table)
>
> PC相关的加载与存储**伪指令**：
>
> - `la` Load Address 用于加载**任意地址**（全局符号、跨模块符号等），支持所有地址范围。
> - `lla` Load Local Address 仅用于加载**当前编译单元内的局部地址**（如函数内的局部变量、同一模块内的静态符号），地址范围限制在当前链接区域内（通常是 ±2GiB）。
> - 加载
>   - `lb`
>   - `lh`
>   - `lw`
>   - `ld` Load Double 从内存中读取一个 64 位（双字，doubleword）数据到指定寄存器。
> - 存储
>   - `sb`
>   - `sh`
>   - `sw`
>   - `sd` Save Double 将寄存器中的 64 位数据写入内存。
> - `li` Load Immediate 将一个立即数加载到指定寄存器（伪指令，由汇编器转换为实际指令）

| 伪指令                 | 指令组合                                                     | 说明                                                |
| ---------------------- | ------------------------------------------------------------ | --------------------------------------------------- |
| la rd, symbol(NOT PIC) | auipc rd,delta[31:12] + delta[11]<br />addi rd, rd, delta[11:0] | 加载符号的绝对地址<br />其中delta = symbol-pc       |
| la rd, symbol(PIC)     | auipc rd, delta[31:12] + delta[11]<br />l{w \| d} rd, rd, `delta[11:0](rd)` | 加载符号的绝对地址<br />其中delta =GOT[symbol] - pc |
| lla rd, symbol         | auipc rd, delta[31:12] + delta[11]<br />addi rd, rd, delta[11:0] | 加载符号本地地址<br />其中delta = symbole - pc      |

#### 3-7

##### main.c

```c
extern void asm_test(void);

int main(void)
{
        asm_test();

        return 0;
}
```

##### asm.S

```assembly
.globl my_test_data

my_test_data:
        .dword 0x12345678abcdabcd

.global asm_test

asm_test:
        la  t0, my_test_data
        lla t1, my_test_data
        ret
```

##### 编译（关闭PIC）

```bash
gcc main.c asm.S -fno-pic -O2 -g -o test

# 反汇编
objdump -d test
```

##### 反汇编代码

可以看到，在代码中，`la` 和 `lla` 这两条伪指令都被编译为了 `auipc` 和 `addi` 指令。

但是他们 `addi` 操作的目标立即数不一样，因为 `auipc` 是基于PC计算的：在两次执行 `auipc` 指令时，他们的PC是不一样的，也就是说他们跳转到同一个地址的时候偏移量是不一样的。

```assembly
110 00000000000005f4 <my_test_data>:
111  5f4:   abcd                    j       be6 <__FRAME_END__+0x53e>
112  5f6:   abcd                    j       be8 <__FRAME_END__+0x540>
113  5f8:   5678                    lw      a4,108(a2)
114  5fa:   1234                    addi    a3,sp,296
115
116 00000000000005fc <asm_test>:
117  5fc:   00000297                auipc   t0,0x0
118  600:   ff828293                addi    t0,t0,-8 # 5f4 <my_test_data>
119  604:   00000317                auipc   t1,0x0
120  608:   ff030313                addi    t1,t1,-16 # 5f4 <my_test_data>
121  60c:   8082                    ret
```

##### 编译（开启PIC）

```bash
# 编译
gcc main.c asm.S -fpic -O2 -g -o test-pic

# 反汇编
objdump -d test-pic > test-pic.dump
```

##### 反汇编代码（开启PIC）

PIC模式下，LA伪指令是AUIPC和LD指令的集合，它会访问GOT，然后从GOT中获取my_test_data符号的地址；而LLA伪指令是AUIPC和ADDI指令的集合，可直接获取my_test_data符号的绝对地址：

- `la` auipc 计算得到的结果是 `0x263c`，`ld` 读取 `t0` 相对偏移量位置的内存数据到寄存器：
  - 此时 `t0` 的值是 `0x263c`（来自上一步）
  - 偏移量是 `-1548`（十进制），转换为 16 进制为 `-0x60C`（因为 `0x60C = 1548`）
  - 内存访问地址 = `0x263c` + (`-0x60C`) =  `0x2030`
- `lla` 这个开启PIC关闭PIC生成的代码是一样的，因为都是相对地址；

```assembly
0000000000000634 <my_test_data>:
 634:   abcd                    j       c26 <__FRAME_END__+0x53e>
 636:   abcd                    j       c28 <__FRAME_END__+0x540>
 638:   5678                    lw      a4,108(a2)
 63a:   1234                    addi    a3,sp,296

000000000000063c <asm_test>:
 63c:   00002297                auipc   t0,0x2
 640:   9f42b283                ld      t0,-1548(t0) # 2030 <_GLOBAL_OFFSET_TABLLE_+0x10>
 644:   00000317                auipc   t1,0x0
 648:   ff030313                addi    t1,t1,-16 # 634 <my_test_data>
 64c:   8082                    ret
```

##### _GLOBAL_OFFSET_TABLLE_

我们可以注意到，我们最终计算的内存地址为 **0x2030**，然而在我们的反汇编数据中并没有 0x2030 这个地址值。**这是因为，在使用 `-fpic`（生成位置无关代码）编译时，`0x2030` 这类地址是**程序运行时的虚拟地址**，而非静态反汇编中直接可见的 “数据值”—— 静态反汇编只能看到地址的 “符号关联”（如 `_GLOBAL_OFFSET_TABLE_+0x10`）**

我们有一行注释：`# 2030 <_GLOBAL_OFFSET_TABLLE_+0x10>`。这里的 `_GLOBAL_OFFSET_TABLLE_` 表示的是 `全局偏移表（GOT）`。

> 为什么静态反汇编看不到 `0x2030` 的数据？

GOT 有两个关键特性：

1. **数据在运行时填充**：GOT 表项存储的是全局符号（如外部函数、全局变量）的**实际运行时地址**，这个地址由操作系统的动态链接器（如 `ld-linux.so`）在程序启动时计算并填充，静态反汇编（分析编译后的二进制文件）阶段，GOT 表项的初始值通常是 “占位符” 或 “重定位信息”，而非最终运行时数据。
2. **静态反汇编默认不显示数据段细节**：`objdump -d` 仅反汇编**代码段（.text）**，而 GOT 属于**数据段（.got 或 .got.plt）**，静态反汇编代码段时，只会标注 `0x2030` 是 `_GLOBAL_OFFSET_TABLE_+0x10`，不会显示该地址在数据段中存储的内容。

在我们的代码中， 我们想要访问的数据 `my_test_data`，这个数据在 test-pic 中的地址是 0x634，但是在真实的执行的时候，才会按照特定的规则去分配到对应的段中（例如 `.rodata`, `.data`），这里：

- `0x634` **静态二进制文件（test-pic）中的链接地址**（编译链接时确定的 “理论地址”）
- `0x2030` 运行时的地址是操作系统分配的 **虚拟地址**（动态地址）

两者的差异是 `-fpic`（位置无关代码）和动态链接的核心特点：

| 地址类型       | 确定时机     | 作用场景                 | 示例（你的代码）       |
| -------------- | ------------ | ------------------------ | ---------------------- |
| 静态链接地址   | 编译链接阶段 | 二进制文件内部的地址引用 | `my_test_data` = 0x634 |
| 运行时虚拟地址 | 程序加载阶段 | 程序实际执行时的内存地址 | 如 `0x555555556040`    |

`-fpic` 编译的核心是让代码 “不依赖固定地址”，而是通过 **全局偏移表（GOT）** 动态获取符号地址，这个 “重定位规则” 由 **ELF 动态链接标准** 定义，与操作系统（如 Linux）强相关：

1. **静态阶段（编译链接）**：
   编译器不知道 `my_test_data` 的运行时地址，因此在代码中（如 `ld t0, -1548(t0)`）通过 `_GLOBAL_OFFSET_TABLE_`（GOT）间接引用 ——GOT 表项（如 `0x2030`）在静态阶段是 “占位符”，仅记录 “需要关联 `my_test_data`” 的重定位信息（通过 `readelf -r` 可查看）。
2. **运行阶段（加载执行）**：
   操作系统的 **动态链接器（如 `ld-linux.so`）** 会：
   - 加载 `test-pic` 到内存，为其分配一段连续的虚拟地址空间（如 `0x555555554000` 开始）；
   - 解析 GOT 表中的重定位信息，找到 `my_test_data` 在运行时的虚拟地址（如 `0x555555556040`）；
   - 将该地址填入 GOT 表项（如 `0x2030`），最终代码通过 `ld` 指令从 `0x2030` 读取到真实地址，再访问 `my_test_data`。

##### GOT

```assembly
Relocation section '.rela.dyn' at offset 0x438 contains 9 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000001e08  000000000003 R_RISCV_RELATIVE                     59e
000000001e10  000000000003 R_RISCV_RELATIVE                     632
000000001e18  000000000003 R_RISCV_RELATIVE                     5f8
000000002000  000000000003 R_RISCV_RELATIVE                     2000
000000002030  000000000003 R_RISCV_RELATIVE                     634
000000002038  000000000003 R_RISCV_RELATIVE                     560
000000002028  000200000002 R_RISCV_64        0000000000000000 _ITM_deregisterTM[...] + 0
000000002040  000400000002 R_RISCV_64        0000000000000000 __cxa_finalize@GLIBC_2.27 + 0
000000002048  000500000002 R_RISCV_64        0000000000000000 _ITM_registerTMCl[...] + 0

Relocation section '.rela.plt' at offset 0x510 contains 1 entry:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000002018  000300000005 R_RISCV_JUMP_SLOT 0000000000000000 __libc_start_main@GLIBC_2.27 + 0
```

##### 关于GOT的总结

在我们开启PIC编译的情况下，在我们的目标文件中会有两个核心部分：

- 静态链接地址
- GOT表

在我们的这个例子中，我们的数据和GOT表分别如下：

```assembly
0000000000000634 <my_test_data>:
 634:   abcd                    j       c26 <__FRAME_END__+0x53e>
 636:   abcd                    j       c28 <__FRAME_END__+0x540>
 638:   5678                    lw      a4,108(a2)
 63a:   1234                    addi    a3,sp,296
```

```assembly
000000002030  000000000003 R_RISCV_RELATIVE                     634
```

而我们可以看到，在 `GOT` 表中的 `0x2030` 指向了 `634` 这个数据的实际地址，也就是说，如果我们想要访问这个数据，那么我们需要做的是让我们的地址指向 GOT 表的 `0x2030`地址。

#### 3-8

```assembly
.global asm_test
asm_test:
	li t0, 0xffffffff08020000
	ret
```

```bash
gcc main.c li.S -O2 -g -o li
```

```assembly
00000000000005f4 <asm_test>:
 5f4:   72e1                    lui     t0,0xffff8
 5f6:   4012829b                addiw   t0,t0,1025
 5fa:   02c6                    slli    t0,t0,0x11
 5fc:   8082                    ret
```

